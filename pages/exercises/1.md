# Utilisation de Zod

Youhou c'est parti pour l'exercice 1 dans un nouveau projet. Fais attention de bien
regarder la vid√©o d'introduction pour d√©couvrir toutes les subtilit√©s de ce projet.

Durant ce projet, on va cr√©er un "clone" vraiment light de Twitter. Attention, je ne vais pas te demander de g√©rer la base de donn√©es etc... le but est vraiment de se concentrer sur les comp√©tences que tu as apprises durant le cours.

Nous verrons dans la suite du projet, le routing avec NextJS, les pages etc...

Que l'on soit clair, tu as normalement d√©j√† d√©couvert `Zod` √† cette √©tape. Si ce n'est
pas le cas, je te conseille de regarder le cours sur le sujet dans le module concernant Zod.

## Part 1 : Zod

Comme tu peux le voir dans le fichier `1.tsx` j'ai d√©j√† pr√©par√© le squelette de ton projet. J'ai cr√©√© les composants React pour afficher notre application Twitter, c'est juste du `JSX` avec `tailwind` et des props.

Dans ce premier exercice, j'ai un probl√®me, mon `fetch` n'est pas typ√©.

```ts
useEffect(() => {
  fetch('/api/tweets')
    .then((res) => res.json())
    .then((data) => setTweets(data.tweets)); // data: any ‚ö†Ô∏è
}, []);
```

J'aimerais que tu utilises `zod` pour cr√©er un sch√©ma qui repr√©sente les donn√©es que je
re√ßois du serveur. Pour trouver les donn√©es, tu peux

- `console.log(data)` pour voir √† quoi ressemblent les donn√©es
- aller dans le fichier [tweets.ts](pages/api/tweets.ts) pour voir la query que je fais
- ouvrir l'endpoint des tweets [http://localhost:5174/api/tweets](http://localhost:5174/api/tweets) pour voir √† quoi ressemblent les donn√©es

‚ÑπÔ∏è Sur Chrome, tu peux installer l'extension [JSON Formatter](https://chrome.google.com/webstore/detail/json-formatter/bcjindcccaagfpapjjmafapmmgkkhgoa/related?hl=pt) pour afficher les jsons de mani√®re plus lisible.

‚ö†Ô∏è Tu ne connais peut-√™tre pas `prisma` que j'utilise durant cet exercice, il me permet
de faire des appels directement √† la database. Ne t'inqui√®te pas, on le d√©couvrira dans le module 3 concernant NextJS.

En plus de √ßa, pense √† utiliser un `abortController` pour annuler le fetch si le
composant est d√©mont√© (avec la cleanup fonction du useEffect).

Dans le cas ou il y a une erreur, tu peux utiliser la fonction `notifyFailed` que j'ai cr√©√©e dans le fichier pour afficher un toast.

Tu peux aussi afficher un Loader quand il y a 0 tweet.

üíå Tu apprends √† valider des donn√©es avec `zod` et √† les utiliser dans ton code.

## Part 2 : refactor dans une fonction

Je te propose de cr√©er une fonction `getTweets` qui va

- `fetch` les donn√©es
- v√©rifier que la r√©ponse est `ok`
- v√©rifier que les donn√©es sont bien typ√©es avec ton sch√©ma zod

Tu vas ensuite pouvoir l'utiliser dans le `useEffect`. (n'oublie pas d'ajouter une props
pour le `signal`).

Ta fonction `getTweets` retournera la promesse resolve uniquement si le sch√©ma est valid√©.

## Part 3 : G√©n√©rique fetch

On va cr√©er une fonction `client` qui va s'occuper de fetch les donn√©es pour nous.

Elle permet de fetch notre backend, de parse le json, et de v√©rifier notre sch√©ma ainsi que de typer les valeurs de retour.

Cette partie est plut√¥t compliqu√©e, dure √† expliquer donc voici le d√©but de la fonction
que tu peux utiliser et modifier en suivant les conseils de ü¶Å.

Dans la vid√©o solution, je vais t'expliquer tout √ßa.

```ts
// Dans ClientConfig on r√©cup√®re le params T
export type ClientConfig<T> = {
  data?: unknown;
  // On utilise T dans le zod schema
  // Ce qui va faire que notre fetch va √™tre automatiquement √™tre typ√© en fonction du sch√©ma
  zodSchema?: z.ZodSchema<T>;
  method?: 'DELETE' | 'GET' | 'OPTIONS' | 'PATCH' | 'POST' | 'PUT';
  headers?: HeadersInit;
  // Pour pouvoir override la config
  customConfig?: RequestInit;
  signal?: AbortSignal;
};

// On utilise un g√©n√©rique ici pour automatiquement typer le retour de la fonction
export async function client<T>(
  url: string,
  {
    data,
    zodSchema,
    method,
    headers: customHeaders,
    signal,
    customConfig,
  }: ClientConfig<T> = {} // On passe T en param√®tre de ClientConfig
): Promise<T> {
  // On retourne Promise<T> pour que le type soit automatiquement d√©duit
  const config: RequestInit = {
    // S'il n'y a pas de method on utilise POST s'il y a des donn√©es et GET sinon
    method: method ?? (data ? 'POST' : 'GET'),
    // On stringify les donn√©es s'il y en a
    body: data ? JSON.stringify(data) : null,
    headers: {
      'Content-Type': data ? 'application/json' : '',
      Accept: 'application/json',
      // Mais on laisse l'utilisateur override les headers
      ...customHeaders,
    },
    signal,
    // On laisse l'utilisateur override la config
    // S'il passe body, method, headers, etc... on les √©crasera
    ...customConfig,
  };

  return window.fetch(url, config).then(async (response) => {
    // on g√®re le status 401 en arr√™tant directement la request
    if (response.status === 401) {
      return Promise.reject(new Error("You're not authenticated"));
    }

    let result = null;
    // ü¶Å √† toi de parse le json dans un try catch

    if (response.ok) {
      // ü¶Å s'il y a un `zodSchema`, on parse `result` sinon on retourne `result`
    } else {
      // ü¶Å on reject la promesse avec le `result`
    }
  });
}
```

Par la suite, tu peux remplacer √† l'int√©rieur de la fonction `getTweets` en utilisant
`client` √† la place de `fetch`. Tu pourras passer le sch√©ma en param√®tre, le retour sera
automatiquement typ√©.
