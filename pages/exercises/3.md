# L'update optimiste

Pour faire cet exercice, n'oublie pas de lire la partie du cours sur les mutations
et l'update optimiste.

On va faire fonctionner le bouton like durant cette exercice.

Le but est d'afficher le like avant mÃªme de l'avoir fait, pour ne pas faire
attendre inutilement l'utilisateur.

â„¹ï¸ J'ai crÃ©Ã© un composant `TweetForm` avec le code fait ensemble que j'ai dÃ©placÃ©.

## Part 1 : Like / dislike

On va dans une premiÃ¨re Ã©tape faire **sans useQuery**. Pour Ã§a, tu peux suivre les
instructions du ðŸ¦.

Mais en gros, tu vas utiliser remplir la fonction `tweetLike` qui va, en fonction
de `liked` la props qui dÃ©finit si oui ou non le tweet Ã  Ã©tÃ© like _par l'utilisateur_,
dÃ©finir la mÃ©thode ("POST" ou "DELETE") et appeler l'url pour crÃ©er ou supprimer
la relation entre le tweet et l'utilisateur.

Dans un deuxiÃ¨me temps on va crÃ©er la fonction `onClick` qui va appeler
la fonction `tweetLike` et :

- si c'est un succÃ¨s (`.then`) : invalider la query des tweets (tu pourras trouver la clÃ© dans [query.tweet.ts](src/lib/tweets/query.tweet.ts) et l'importer)
- si c'est un Ã©chec (`.catch`) : afficher un message d'erreur
- finalement on va dÃ©finir le state `isLoading` Ã  false

## Part 2 : useMutation

Refactor le code de la fonction `onClick` avec un useMutation.

- Tu vas pouvoir supprimer le state `isLoading`
- Tu vas utiliser les paramÃ¨tres `onSuccess` et `onError` pour remplacer le `.then` et le `.catch`

Normalement tout devrait fonctionner comme avant.

## Part 3 : Optimistic update

Maintenant on va utiliser useMutation pour profiter de toute la puissance de useQuery
et surtout intÃ©grer l'optimistic update.

Notre but va Ãªtre de modifier "artificiellement" le cache de la query `tweets`
en faisant liker le tweet par l'utilisateur.

Pour Ã§a il y a deux propriÃ©tÃ©s Ã  changer :

- `liked` qui doit changer de true Ã  false
- `_count.likes` qui doit changer de +1 ou -1 en fonction de `liked`

Tu vas pouvoir supprimer le state `isLoading` car `useMutation` gÃ¨re dÃ©jÃ  ce state.

Puis on va crÃ©er notre mutation en suivant ce qu'on a fait durant le cours.

Tu peux suivre ces instructions :

```js
// ðŸ¦ Ajoute un hook useMutation qui va
// * utiliser la fonction likeTweet
// * utilise le paramÃ¨tre `onMutate` pour mettre Ã  jour le cache
//   * utilise la mÃªme syntaxe que dans mon cours
//   * invalide le cache de la query `tweets`
//   * utilise `queryClient.getQueryData` pour rÃ©cupÃ©rer le cache et le stocker dans une variable
//   * utilise `queryClient.setQueryData` pour mettre Ã  jour le cache en fonction de liked
// * utilise le paramÃ¨tre `onError` pour afficher une notification d'erreur et rollback le cache
//   * tu peux utiliser la fonction `notifyFailed`
// * utilise le paramÃ¨tre `onSuccess` pour invalider le cache de la query `tweets` afin de faire une requÃªte (en suivant les instructions de l'exercice)
```

Pour invalider la query, il va falloir passer un argument supplÃ©mentaire :

```ts
void queryClient.invalidateQueries({
  queryKey: tweetKeys.all,
  // function qui dÃ©termine s'il doit refresh ou pas la page courante !
  refetchPage: (lastPage: TlTweetsPage) => {
    return; /* un boolean, true is la page modifier contient l'id du tweet courant */
  },
});
```

Ce n'est pas un exercice facile, mais en t'aidant du cours, d'internet et de discord tu devrais
facilement rÃ©ussir. Tu verras le grand avantage que Ã§a apporte.

Pour la partie "algorithmie" qui est d'aller chercher les bonnes propriÃ©tÃ©s Ã  changer
et de les modifier, voici une petite aide :

```ts
queryClient.setQueryData(tweetKeys.all, (old?: { pages: TlTweetsPage[] }) => {
  // S'il n'y a pas de donnÃ©es, on fait rien !
  if (!old) {
    return old;
  }

  return {
    pages: old.pages.map((page) => {
      return {
        ...page,
        tweets: /* Ã  toi de jouer */
      };
    }),
  };
});
```
