# L'update optimiste

Pour faire cette exercice, n'oublie pas de lire la partie du cour sur les mutations
et l'update optimiste.

On va faire fonctionnÃ© le bouton like durant cette exercice.

Le but est d'affichÃ© le like avant mÃªme de l'avoir fait, pour ne pas faire
attendre inutilement l'utilisateur.

â„¹ï¸ J'ai crÃ©er un composant `TweetForm` avec le code fait ensemble que j'ai dÃ©placer.

## Part 1 : Like / dislike

On va dans une premiÃ¨re Ã©tape faire **sans useQuery**. Pour Ã§a, tu peux suivre les
instructions du ðŸ¦.

Mais en gros, tu vas utiliser remplir la fonction `tweetLike` qui va, en fonction
de `liked` la props qui dÃ©finit si oui ou non le tweet Ã  Ã©tÃ© like _par l'utilisateur_,
dÃ©finir la mÃ©thode ("POST" ou "DELETE") et appelÃ© l'url pour crÃ©er ou supprimÃ©
la relations entre le tweet et l'utilisateur.

Dans un deuxiÃ¨me temps on va crÃ©er la fonction `onClick` qui va appelÃ©
la fonction `tweetLike` et :

- si c'est un succÃ¨s (`.then`) : invalidÃ© la query des tweets (tu pourras trouver la clÃ© dans [query.tweet.ts](src/lib/tweets/query.tweet.ts) et l'importer)
- si c'est un Ã©chec (`.catch`) : affichÃ© un message d'erreur
- finalement on va dÃ©finir le state `isLoading` Ã  false

## Part 2 : useMutation

Refactor le code de la fonction `onClick` avec un useMutation.

- Tu vas pouvoir supprimer le state `isLoading`
- Tu vas utiliser les paramÃ¨tres `onSuccess` et `onError` pour remplacer le `.then` et le `.catch`

Normalement tout devrait fonctionnÃ© comme avant.

## Part 3 : Optimistic update

Maintenant on va utilisÃ© useMutation pour profiter de toute la puissance de useQuery
et surtout intÃ©grer l'optimistic update.

Notre but va Ãªtre de modifier "artificiellement" le cache de la query `tweets`
en faisant likÃ© le tweet par l'utilisateur.

Pour Ã§a il y a de propriÃ©tÃ© Ã  changer :

- `liked` qui doit changer de true Ã  false
- `_count.likes` qui doit changer de +1 ou -1 en fonction de `liked`

Tu vas pouvoir supprimer le state `isLoading` car `useMutation` gÃ¨re dÃ©jÃ  ce state.

Puis on va crÃ©er notre mutation en suivant ce qu'on a fait durant le cours.

Tu peux suivre ses instructions :

```js
// ðŸ¦ Ajoute un hooks useMutation qui va
// * utiliser la fonction likeTweet
// * utilise le paramÃ¨tre `onMutate` pour mettre Ã  jour le cache
//   * utilise la mÃªme syntaxe que dans mon cours
//   * invalid le cache de la query `tweets`
//   * utilise `queryClient.getQueryData` pour rÃ©cupÃ©rer le cache et le stoker dans une variable
//   * utilise `queryClient.setQueryData` pour mettre Ã  jour le cache en fonction de liked
// * utilise le paramÃ¨tre `onError` pour afficher une notification d'erreur et rollback le cache
//   * tu peux utiliser la fonction `notifyFailed`
// * utilise le paramÃ¨tre `onSuccess` pour invalider le cache de la query `tweets` afin de faire une requÃªte (en suivant les instructions de l'exercice)
```

Pour invalider la query, il va falloir passer un argument supplÃ©mentaire :

```ts
void queryClient.invalidateQueries({
  queryKey: tweetKeys.all,
  // function qui dÃ©termine si il doit refresh ou pas la page courante !
  refetchPage: (lastPage: TlTweetsPage) => {
    return; /* un boolean, true is la page modifier contient l'id du tweet courant */
  },
});
```

C'est pas un exercice facile, mais en t'aidant du cours, d'internet de du discord tu devrais
facilement rÃ©ussir. Tu verras le grand avantage que Ã§a apporte.

Pour la partie "algoritmie" qui est d'aller chercher les bonnes propriÃ©tÃ©s Ã  changer
et de les modifiers, voici une petite aide :

```ts
queryClient.setQueryData(tweetKeys.all, (old?: { pages: TlTweetsPage[] }) => {
  // Si il n'y a pas de donnÃ©es, on fait rien !
  if (!old) {
    return old;
  }

  return {
    pages: old.pages.map((page) => {
      return {
        ...page,
        tweets: /* Ã  toi de jouer */
      };
    }),
  };
});
```
